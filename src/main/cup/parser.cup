package gt.edu.usac.compiler;
import java_cup.runtime.*;

class MyParser;
parser code{:
 public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        System.out.println("El error es el simbolo: " + MyParserSym.terminalNames[cur_token.sym]);
        System.out.println(String.format("En la posicion: %d, %d", cur_token.left, cur_token.right));
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == MyParserSym.EOF) {
            System.out.println("public void unrecoveredsyntax_error");
        }
    }
:}
/**Simbolos terminales**/
terminal PLUS, TIMES, LPAREN, RPAREN, MINUS, DIV, MOD, UMINUS;
terminal LBRACE, RBRACE, COMMA, VOID,SEMI, ASIGN;
terminal Double NUMBER,FOR;
terminal INT,LONG,FLOAT,DOUBLE,DECIMAL,STRING;
terminal CHAR,BOOL,ERROR, LT, GT, LET, LGT;
terminal String identifier;
terminal doubleValue, stringValue, intValue, charValue;
terminal WHILE;
terminal TRUE;
terminal FALSE;
terminal DO;
terminal ELSE;
terminal IF;
terminal NOT;
terminal AND;
terminal OR;
terminal CONTINUE;
terminal BREAK;
terminal RETURN;
terminal MAIN;
terminal COLON;
terminal SWITCH;
terminal DEFAULT;
terminal CASE;
terminal CONSOLE;
terminal DOT;
terminal WRITE;


/**Simbolos no terminales**/
non terminal Double expr;
non terminal String inicio;
non terminal String funcion;
non terminal String tipo;
non terminal String ids;
non terminal String params;
non terminal String param;
non terminal declaracion;
non terminal llamada;
non terminal atributos;
non terminal sentencia;
non terminal valor;
non terminal asignacion;
non terminal String tipoFun;
non terminal for;
non terminal forVariation;
non terminal declaracionFor;
non terminal while;
non terminal condicion;
non terminal valorCondicion;
non terminal signoCondicion;
non terminal sentencias;
non terminal do;
non terminal if;
non terminal else;
non terminal condicionIf;
non terminal condicionCompleta;
non terminal signoLogico;
non terminal sentenciaCiclo;
non terminal sentenciasCiclo;
non terminal sentenciaSwitch;
non terminal sentenciasSwitch;
non terminal multiCase;
non terminal switch;
non terminal identifiers;
non terminal console;





/*Precedencia*/
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left UMINUS;

start with inicio;

inicio::= ids:i {:RESULT = i;:}
|sentencias
|expr:e {:RESULT = e+"";:}
;

sentenciasCiclo::=sentenciaCiclo
|sentenciasCiclo sentenciaCiclo
;

sentencias::= sentencia
|sentencias sentencia
;

sentencia::=if
|do
|while
|for
|switch
|asignacion
|declaracion
|console
|llamada SEMI
|RETURN valor SEMI
|RETURN identifier SEMI
|RETURN SEMI
|RETURN llamada
;

console::= CONSOLE DOT WRITE LPAREN valorCondicion RPAREN SEMI
;

sentenciaCiclo::= sentencia
|BREAK
|CONTINUE
;


if::= IF LPAREN condicionCompleta RPAREN LBRACE sentencias RBRACE
|IF LPAREN condicionCompleta RPAREN LBRACE sentencias RBRACE ELSE if
|IF LPAREN condicionCompleta RPAREN LBRACE sentencias RBRACE ELSE LBRACE sentencias RBRACE
|IF LPAREN condicionCompleta RPAREN LBRACE RBRACE
|IF LPAREN condicionCompleta RPAREN LBRACE RBRACE ELSE if
|IF LPAREN condicionCompleta RPAREN LBRACE RBRACE ELSE LBRACE sentencias RBRACE
|IF LPAREN condicionCompleta RPAREN LBRACE sentencias RBRACE ELSE LBRACE RBRACE
|IF LPAREN condicionCompleta RPAREN LBRACE RBRACE ELSE LBRACE RBRACE
;

condicionCompleta ::= condicionIf
|condicionCompleta signoLogico condicionIf
;

condicionIf::=condicion
|identifier
|NOT identifier
;

do::= DO LBRACE sentencias RBRACE  WHILE LPAREN condicionCompleta RPAREN SEMI
|DO LBRACE RBRACE  WHILE LPAREN condicionCompleta RPAREN SEMI
;
//********WHILE**********
while::= WHILE LPAREN condicionCompleta RPAREN LBRACE sentenciasCiclo RBRACE
|WHILE LPAREN condicionCompleta RPAREN LBRACE  RBRACE
;

condicion::= valorCondicion signoCondicion valorCondicion
|TRUE
|FALSE
;

valorCondicion::= identifier
|valor
|llamada
;

signoLogico::=AND AND
|OR OR
;

signoCondicion::=LT
|GT
|LET
|LGT
|ASIGN ASIGN
|NOT ASIGN
;
//********FOR**********
for::=FOR LPAREN declaracionFor RPAREN LBRACE sentenciasCiclo RBRACE
|FOR LPAREN declaracionFor RPAREN LBRACE  RBRACE
;

declaracionFor::= tipo identifier ASIGN valor SEMI identifier LT valor SEMI identifier forVariation
|identifier ASIGN valor SEMI identifier LT valor SEMI identifier forVariation
;

forVariation::= PLUS PLUS
|MINUS MINUS
;
//********SWITCH**************

switch::= SWITCH LPAREN identifier RPAREN LBRACE multiCase DEFAULT COLON sentencias BREAK SEMI RBRACE
;

multiCase::= CASE valorCondicion COLON sentencias BREAK SEMI multiCase
|CASE valorCondicion COLON sentencias multiCase
|CASE valorCondicion COLON sentencias BREAK SEMI 
|CASE valorCondicion COLON sentencias 
;


//********ASIGNACION**********
asignacion::=identifier ASIGN valor SEMI
|identifier ASIGN llamada SEMI
;

//********DECLARACION**********
declaracion::=tipo identifiers SEMI
|tipo identifiers ASIGN valorCondicion SEMI
;

identifiers::= identifier
|identifiers COMMA identifier
;

//********LLAMADA**********
llamada::=identifier LPAREN RPAREN 
|identifier LPAREN atributos RPAREN
;

//********ATRIBUTOS**********
atributos::=identifier
|atributos identifier
;


params::= param
|params COMMA param
;

param::= tipo identifier
;

//********FUNCION**********
ids::= tipo:i identifier:t LPAREN RPAREN LBRACE  sentencias RBRACE{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|tipo:i identifier:t LPAREN params RPAREN LBRACE sentencias RBRACE{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|VOID identifier:t LPAREN  RPAREN LBRACE sentencias RBRACE{:System.out.println(t);RESULT=t;:}
|VOID identifier:t LPAREN params RPAREN LBRACE  sentencias RBRACE{:System.out.println(t);RESULT=t;:}
|tipo:i identifier:t LPAREN RPAREN LBRACE   RBRACE{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|tipo:i identifier:t LPAREN params RPAREN LBRACE  RBRACE{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|VOID identifier:t LPAREN  RPAREN LBRACE  RBRACE{:System.out.println(t);RESULT=t;:}
|VOID identifier:t LPAREN params RPAREN LBRACE   RBRACE{:System.out.println(t);RESULT=t;:}
|VOID MAIN LPAREN RPAREN LBRACE  sentencias RBRACE
|VOID MAIN LPAREN RPAREN LBRACE RBRACE
;



//********EXPRESION**********
expr::= expr:e1 PLUS expr:e2 {:RESULT = new Double(e1.doubleValue() + e2.doubleValue());:}
    | PLUS PLUS expr:e1      {:RESULT = new Double(e1.doubleValue()+1);:}
    | expr:e1 MINUS expr:e2  {:RESULT = new Double(e1.doubleValue() - e2.doubleValue());:} 
    | expr:e1 TIMES expr:e2  {:RESULT = new Double(e1.doubleValue() * e2.doubleValue());:}
    | expr:e1 DIV expr:e2    {:if(e2.doubleValue()!=0){RESULT = new Double(e1.doubleValue() / e2.doubleValue());}:}
    | expr:e1 MOD expr:e2    {:RESULT = new Double(e1.doubleValue() % e2.doubleValue());:}
    | MINUS expr:e {: RESULT = new Double(e.doubleValue());:} %prec UMINUS
    | LPAREN expr:e RPAREN {:RESULT = e;:}
    | NUMBER:e {:RESULT = e;:}
;
valor::= NUMBER
    |doubleValue
    |intValue
    |charValue
    |stringValue
;

tipo::=INT {:System.out.println("INT");RESULT = "INT";:}
    |LONG   {:System.out.println("LONG");RESULT ="LONG";:}
    |FLOAT  {:System.out.println("FLOAT");RESULT ="FLOAT";:}
    |DOUBLE {:System.out.println("DOUBLE");RESULT ="DOUBLE";:}
    |DECIMAL{:System.out.println("DECIMAL");RESULT ="DECIMAL";:} 
    |STRING {:System.out.println("STRING");RESULT ="STRING";:}
    |CHAR   {:System.out.println("CHAR");RESULT ="CHAR";:}
    |BOOL   {:System.out.println("BOOL");RESULT ="BOOL";:}
    |identifier:i {:System.out.println(i); RESULT = i;:}
;
tipoFun::= tipo
    |VOID   {:System.out.println("VOID");RESULT ="VOID";:}
;

