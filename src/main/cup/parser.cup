package gt.edu.usac.compiler;
import java_cup.runtime.*;
import java.util.*;
import Data.*;
class MyParser;
parser code{:

    int tabs = 0;
    boolean lock = false;
    StringBuilder salida = new StringBuilder();

    LinkedList<Expresion> expresiones = new LinkedList<>();
    LinkedList<Expresion> secundaria = new LinkedList();
    
    private void addLine(){
        salida.append("\n");
    }
    private void addText(String valor){
        salida.append(valor);
    }
    private void addTabs(){
        salida.append("\n");
        for (int i = 0; i < tabs; i++) {
            salida.append("\t");
        }
    }
        public String getSalida(){
        String exit = salida.toString();
        String[] lineas = salida.toString().split("\n");
        StringBuilder nuevo = new StringBuilder();
        for (int i = lineas.length-1; i >= 0; i--) {
            if (!lineas[i].isEmpty()&&!lineas[i].isBlank()) {
                nuevo.append(lineas[i]).append("\n");
            }
        }
        ArrayList<Integer> cantTabs = contarTabs(nuevo.toString().split("\n"));
        int maxTabs = maxTabNum(cantTabs);
        
        Extras.Formatter formatter= new Extras.Formatter();
        //formatter.Reformat(nuevo.toString().split("\n"), 0, maxTabs, 0, lineas.length, 0);
        return nuevo.toString();
    }
        
  
       public ArrayList<Integer> contarTabs(String[] lineas){
        ArrayList<Integer> cantTabs = new ArrayList<>();
        for (int i = 0; i < lineas.length; i++) {
            char[] caracteres = lineas[i].toCharArray();
            int contador = 0;
            for (int j = 0; j < caracteres.length; j++) {
                if (caracteres[j] == '\t') {
                    contador++;
                }
            }
            cantTabs.add(contador);
            contador = 0;
        }
        maxTabNum(cantTabs);
        System.out.println(cantTabs.toString());
        return cantTabs;
    }

    public int maxTabNum(ArrayList<Integer> cantTabs) {
        int salida = 0;
        for (int i = 0; i < cantTabs.size(); i++) {
            if (cantTabs.get(i) > salida) {
                salida = cantTabs.get(i);
            }
        }
        System.out.println("NUMERO MAXIMO TABS: "+salida);
        return salida;
    }
     public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        System.out.println("El error es el simbolo: " + MyParserSym.terminalNames[cur_token.sym]);
        System.out.println(String.format("En la posicion: %d, %d", cur_token.left, cur_token.right));
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == MyParserSym.EOF) {
            System.out.println("public void unrecoveredsyntax_error");
        }
    }
:}
/**Simbolos terminales**/
terminal PLUS, TIMES, LPAREN, RPAREN, MINUS, DIV, MOD, UMINUS;
terminal LBRACE, RBRACE, COMMA, VOID,SEMI, ASIGN;
terminal Double NUMBER,FOR;
terminal INT,LONG,FLOAT,DOUBLE,DECIMAL,STRING;
terminal CHAR,BOOL,ERROR, LT, GT, LET, LGT;
terminal String identifier;
terminal double doubleValue;
terminal String stringValue;
terminal int intValue;
terminal String charValue;
terminal WHILE;
terminal TRUE;
terminal FALSE;
terminal DO;
terminal ELSE;
terminal IF;
terminal NOT;
terminal AND;
terminal OR;
terminal CONTINUE;
terminal BREAK;
terminal RETURN;
terminal MAIN;
terminal COLON;
terminal SWITCH;
terminal DEFAULT;
terminal CASE;
terminal CONSOLE;
terminal DOT;
terminal WRITE;


/**Simbolos no terminales**/
non terminal Double expr;
non terminal String inicio;
non terminal String tipo;
non terminal String ids;
non terminal String params;
non terminal String param;
non terminal String declaracion;
non terminal String llamada;
non terminal String atributos;
non terminal String sentencia;
non terminal String valor;
non terminal String asignacion;
non terminal String tipoFun;
non terminal String for;
non terminal String forVariation;
non terminal String declaracionFor;
non terminal String while;
non terminal String condicion;
non terminal String valorCondicion;
non terminal String signoCondicion;
non terminal String sentencias;
non terminal String do;
non terminal String if;
non terminal String condicionIf;
non terminal String condicionCompleta;
non terminal String signoLogico;
non terminal String sentenciaCiclo;
non terminal String sentenciasCiclo;
non terminal String multiCase;
non terminal String switch;
non terminal String identifiers;
non terminal  console;
non terminal  llaveApertura;
non terminal  llaveCierre;





/*Precedencia*/
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left UMINUS;

start with inicio;

inicio::= ids:i {:RESULT = getSalida();:}
|sentencias {:RESULT = getSalida();:}
|expr:e {:RESULT = e+"";:}
|error LBRACE
;

sentenciasCiclo::=sentenciaCiclo
|sentenciasCiclo sentenciaCiclo
;

sentencias::= sentencia
|sentencias sentencia
;

sentencia::=if
|do
|while
|for
|switch
|asignacion
|declaracion
|console//en proceso #1
|llamada SEMI
|RETURN valor SEMI
|RETURN identifier SEMI
|RETURN SEMI
|RETURN llamada//en proceso
|error SEMI 
;

console::= CONSOLE DOT WRITE LPAREN valorCondicion RPAREN SEMI //En proceso #1
;

sentenciaCiclo::= sentencia:s {:RESULT = s;:}
|BREAK SEMI{:RESULT = "break;";addLine();:}
|CONTINUE SEMI{:RESULT = "continue;";addLine();:}
;


if::=IF LPAREN condicionCompleta RPAREN llaveApertura sentencias llaveCierre 
|IF LPAREN condicionCompleta RPAREN llaveApertura sentencias llaveCierre ELSE if
|IF LPAREN condicionCompleta RPAREN llaveApertura sentencias llaveCierre ELSE llaveApertura sentencias llaveCierre
|IF LPAREN condicionCompleta RPAREN llaveApertura llaveCierre
|IF LPAREN condicionCompleta RPAREN llaveApertura llaveCierre ELSE if
|IF LPAREN condicionCompleta RPAREN llaveApertura llaveCierre ELSE llaveApertura sentencias llaveCierre
|IF LPAREN condicionCompleta RPAREN llaveApertura sentencias llaveCierre ELSE llaveApertura llaveCierre
|IF LPAREN condicionCompleta RPAREN llaveApertura llaveCierre ELSE llaveApertura llaveCierre
;


do::= DO llaveApertura sentencias llaveCierre  WHILE LPAREN condicionCompleta RPAREN SEMI
|DO llaveApertura llaveCierre  WHILE LPAREN condicionCompleta RPAREN SEMI
;
//********WHILE**********
while::= WHILE LPAREN condicionCompleta:c RPAREN llaveApertura sentenciasCiclo llaveCierre 
{:addText("while "+c+" :");:}
|WHILE LPAREN condicionCompleta:c RPAREN llaveApertura  llaveCierre
{:addText("while "+c+" :");:}
;

condicionCompleta ::= condicionIf:c {:RESULT = c;:}
|condicionCompleta:c1 signoLogico:s condicionIf:c2 {:RESULT = c1+" "+s+" "+c2;:}
;

condicionIf::=condicion:c {:RESULT = c;:}
|identifier:i {:RESULT = i;:}
|NOT identifier:i {:RESULT = "!"+i;:}
;


condicion::= valorCondicion:v1 signoCondicion:s valorCondicion:v2 {:RESULT = v1+" "+s+" "+v2;:}
|TRUE  {:RESULT = "true";:} 
|FALSE {:RESULT = "false";:}
;

valorCondicion::= identifier:i {:RESULT = i;:}//En proceso #2
|valor:v  {:RESULT = v;:}//En proceso #2
|llamada:l {:RESULT = l;:}//En proceso #3
;

signoLogico::=AND AND{:RESULT = "&&";:}
|OR OR{:RESULT = "||";:}
;

signoCondicion::=LT {:RESULT = "<";:}
|GT {:RESULT = ">";:}
|LET {:RESULT = "<=";:}
|LGT {:RESULT = ">=";:}
|ASIGN ASIGN {:RESULT = "==";:}
|NOT ASIGN {:RESULT = "!=";:}
;
//********FOR**********
for::=FOR LPAREN declaracionFor RPAREN llaveApertura sentenciasCiclo llaveCierre
|FOR LPAREN declaracionFor RPAREN llaveApertura  llaveCierre
;

declaracionFor::= tipo identifier ASIGN valor SEMI identifier LT valor SEMI identifier forVariation
|identifier ASIGN valor SEMI identifier LT valor SEMI identifier forVariation
;

forVariation::= PLUS PLUS
|MINUS MINUS
;
//********SWITCH**************

switch::= SWITCH LPAREN identifier RPAREN llaveApertura multiCase DEFAULT COLON sentencias BREAK SEMI llaveCierre
;

multiCase::= CASE valorCondicion COLON sentencias BREAK SEMI multiCase
|CASE valorCondicion COLON sentencias multiCase
|CASE valorCondicion COLON sentencias BREAK SEMI 
|CASE valorCondicion COLON sentencias 
;


//********ASIGNACION**********
asignacion::=identifier ASIGN valorCondicion SEMI

;

//********DECLARACION**********
declaracion::=tipo identifiers SEMI
|tipo identifiers ASIGN valorCondicion SEMI
;

identifiers::= identifier
|identifiers COMMA identifier
;

//********LLAMADA**********
llamada::=identifier:i LPAREN RPAREN {:RESULT = i;:}//En proceso #3
|identifier:i LPAREN atributos:a RPAREN {:RESULT = i+"("+a+")";:}//En proceso #3
;

//********ATRIBUTOS**********
atributos::=identifier:i {:RESULT = i;:}
|valor
|atributos:a COMMA identifier:i {:RESULT = a+" "+i;:}
|atributos COMMA valor
;


params::= param
|params COMMA param
;

param::= tipo identifier
;

//********FUNCION**********
ids::= tipo:i identifier:t LPAREN RPAREN llaveApertura  sentencias llaveCierre{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|tipo:i identifier:t LPAREN params RPAREN llaveApertura sentencias llaveCierre{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|VOID identifier:t LPAREN  RPAREN llaveApertura sentencias llaveCierre{:System.out.println(t);RESULT=t;:}
|VOID identifier:t LPAREN params RPAREN llaveApertura  sentencias llaveCierre{:System.out.println(t);RESULT=t;:}
|tipo:i identifier:t LPAREN RPAREN llaveApertura   llaveCierre{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|tipo:i identifier:t LPAREN params RPAREN llaveApertura  llaveCierre{:System.out.println(i+"  "+t);RESULT=i+"  "+t;:}
|VOID identifier:t LPAREN  RPAREN llaveApertura  llaveCierre{:System.out.println(t);RESULT=t;:}
|VOID identifier:t LPAREN params RPAREN llaveApertura   llaveCierre{:System.out.println(t);RESULT=t;:}
|VOID MAIN LPAREN RPAREN llaveApertura  sentencias llaveCierre
|VOID MAIN LPAREN RPAREN llaveApertura llaveCierre
|error RBRACE
;

llaveApertura::=LBRACE{:tabs++; addTabs();:};
llaveCierre::=RBRACE{:tabs--; addTabs();:};


//********EXPRESION**********
expr::= expr:e1 PLUS expr:e2 {:RESULT = new Double(e1.doubleValue() + e2.doubleValue());:}
    | PLUS PLUS expr:e1      {:RESULT = new Double(e1.doubleValue()+1);:}
    | expr:e1 MINUS expr:e2  {:RESULT = new Double(e1.doubleValue() - e2.doubleValue());:} 
    | expr:e1 TIMES expr:e2  {:RESULT = new Double(e1.doubleValue() * e2.doubleValue());:}
    | expr:e1 DIV expr:e2    {:if(e2.doubleValue()!=0){RESULT = new Double(e1.doubleValue() / e2.doubleValue());}:}
    | expr:e1 MOD expr:e2    {:RESULT = new Double(e1.doubleValue() % e2.doubleValue());:}
    | MINUS expr:e {: RESULT = new Double(e.doubleValue());:} %prec UMINUS
    | LPAREN expr:e RPAREN {:RESULT = e;:}
    | NUMBER:e {:RESULT = e;:}
;
valor::= NUMBER:n {:RESULT = n+"";:}//listo en java
    |doubleValue:d {:RESULT = d+"";:}//listo en java
    |intValue:i {:RESULT = i+"";:}//listo en java
    |charValue:c {:RESULT = c;:}//listo en java
    |stringValue:s {:RESULT = s;:}//listo en java
;

tipo::=INT {:System.out.println("INT");RESULT = "INT";:}
    |LONG   {:System.out.println("LONG");RESULT ="LONG";:}
    |FLOAT  {:System.out.println("FLOAT");RESULT ="FLOAT";:}
    |DOUBLE {:System.out.println("DOUBLE");RESULT ="DOUBLE";:}
    |DECIMAL{:System.out.println("DECIMAL");RESULT ="DECIMAL";:} 
    |STRING {:System.out.println("STRING");RESULT ="STRING";:}
    |CHAR   {:System.out.println("CHAR");RESULT ="CHAR";:}
    |BOOL   {:System.out.println("BOOL");RESULT ="BOOL";:}
    |identifier:i {:System.out.println(i); RESULT = i;:}
;


